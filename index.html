<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>FindCho - 화면 OCR 및 DB 조회</title>
  <style>
    body{font-family: Arial, sans-serif; padding:16px}
    /* 레이아웃: 결과는 왼쪽, 미리보기는 오른쪽 */
    .mainWrap{display:flex; gap:16px; align-items:flex-start; margin-top:8px;}
    .leftCol{width:320px; min-width:240px;}
    .rightCol{flex:1; min-width:360px;}
    #previewWrap{position:relative; border:1px solid #ddd; margin-top:0;}
    video{display:block; width:100%; max-width:900px; max-height:720px; background:#999;}
    #overlay{position:absolute; left:0; top:0; cursor:crosshair;}
    #result{margin-top:12px; padding:8px; border:1px solid #ccc; min-height:28px}
    button{margin-right:8px}
    #hint{font-size:12px; color:#666}
    #log{white-space:pre-wrap; background:#111; color:#efe; padding:8px; margin-top:12px; max-height:180px; overflow:auto; font-size:12px}
    #progressWrap{margin-top:8px; width:100%; max-width:640px}
    #progress{width:100%; height:10px; background:#eee; border:1px solid #ccc}
    #progress > i{display:block; height:100%; width:0%; background:#4caf50}
    /* 실시간 OCR 텍스트 표시창 (간단) */
    #ocrLive { margin-top:8px; padding:6px; border:1px dashed #9c9; min-height:48px; background:#f6fff6; font-size:14px; white-space:pre-wrap; overflow:auto; display:flex; gap:8px; align-items:flex-start; }
    #ocrLiveText { flex:1; white-space:pre-wrap; word-break:break-word; }
    #copyLiveBtn { flex:0 0 auto; padding:6px 8px; font-size:12px; cursor:pointer; }
   </style>
 </head>
 <body>
   <h3>화면 공유 → OCR → DB 조회 → 복사</h3>
  <div class="mainWrap">
    <div class="leftCol">
      <div class="controls" style="display:flex; flex-wrap:wrap; gap:6px;">
        <button id="startBtn">화면 공유 시작</button>
        <button id="stopBtn" disabled>중지</button>
        <button id="copyBtn" disabled>결과 복사</button>
        <button id="resetSelBtn" disabled>영역 초기화</button>
      </div>
      <div id="status" style="margin-top:8px">준비</div>
      <div id="ocrLive">
        <div id="ocrLiveText">실시간 인식 텍스트가 여기에 표시됩니다.</div>
        <button id="copyLiveBtn">실시간 복사</button>
      </div>
      <div id="result">결과가 여기에 표시됩니다.</div>
    </div>

    <div class="rightCol">
      <div id="previewWrap" style="display:none;">
        <video id="screenVideo" autoplay playsinline></video>
        <canvas id="overlay"></canvas>
      </div>

      <canvas id="capCanvas" style="display:none"></canvas>

      <div id="hint">비디오 위에서 드래그하여 캡쳐 영역을 지정하세요. 지정하지 않으면 전체 화면을 캡쳐합니다.</div>

      <div id="progressWrap">
        <div id="progress"><i></i></div>
      </div>

      <div id="log">실시간 로그가 여기에 표시됩니다.</div>
    </div>
  </div>

 <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
 <script>
   const startBtn = document.getElementById('startBtn');
   const stopBtn = document.getElementById('stopBtn');
   const copyBtn = document.getElementById('copyBtn');
   const resetSelBtn = document.getElementById('resetSelBtn');
   const status = document.getElementById('status');
   const resultDiv = document.getElementById('result');
   const liveTextEl = document.getElementById('ocrLiveText');
   const copyLiveBtn = document.getElementById('copyLiveBtn');
   const video = document.getElementById('screenVideo');
   const overlay = document.getElementById('overlay');
   const previewWrap = document.getElementById('previewWrap');
   const canvas = document.getElementById('capCanvas');
   const logEl = document.getElementById('log');
   const progressBar = document.querySelector('#progress > i');
   // Tesseract tessdata 선택: 'tessdata_fast' 또는 'tessdata_best' (크기·정확도 차이)
   const TESSDATA_VARIANT = 'tessdata_best'; // 혹은 'tessdata_fast'
   const TESSDATA_BASE = `https://cdn.jsdelivr.net/gh/tesseract-ocr/${TESSDATA_VARIANT}@main`;

     // 상태/로그/프로그레스 유틸 (추가)
     function log(msg) {
       try {
         const time = new Date().toLocaleTimeString();
         logEl.textContent = `[${time}] ${msg}\n` + logEl.textContent;
       } catch (e) { console.log('log error', e); }
     }

     function setStatus(s) {
       try {
         status.textContent = s;
         log(s);
       } catch (e) { console.log('setStatus error', e); }
     }

     function setProgress(p) {
       try {
         const pct = Math.max(0, Math.min(1, Number(p) || 0));
         progressBar.style.width = Math.round(pct * 100) + '%';
       } catch (e) { console.log('setProgress error', e); }
     }

    // Tesseract 로그 출력 과다 문제를 완화하기 위한 throttle logger
    let _tessLastStatus = '';
    let _tessLastProgress = -1;
    function makeTesseractLogger(prefix = 'tesseract') {
      return function(m) {
        try {
          const status = m && m.status ? String(m.status) : '';
          const progress = (typeof m.progress === 'number') ? m.progress : null;
          // 상태가 바뀌었을 때만 로그 (상태별로 한 번)
          if (status && status !== _tessLastStatus) {
            _tessLastStatus = status;
            log(`${prefix}: ${status}`);
          }
          // 진행률은 5% 단위로만 갱신
          if (progress !== null) {
            const step = 0.05;
            const clamped = Math.min(1, Math.max(0, progress));
            if (_tessLastProgress < 0 || clamped - _tessLastProgress >= step || clamped === 1) {
              _tessLastProgress = clamped;
              setProgress(clamped);
              log(`${prefix}: progress ${(Math.round(clamped*100))}%`);
            }
          }
        } catch (e) {
          // 무시
        }
      };
    }

     // 텍스트 정규화: 한글 자음만 추출
     function normalizeKey(s) {
       if (!s) return '';
       let t = String(s).normalize('NFC');
       
       // 한글 자음 유니코드 범위 (ㄱ-ㅎ): \u3131-\u314E
       const consonants = [];
       
       for (let i = 0; i < t.length; i++) {
         const char = t[i];
         const code = char.charCodeAt(0);
         
         // 완성된 한글에서 자음 추출 (가-힣: AC00-D7A3)
         if (code >= 0xAC00 && code <= 0xD7A3) {
           const syllableIndex = code - 0xAC00;
           // 초성 추출
           const initialIndex = Math.floor(syllableIndex / 588);
           const initialCode = 0x3131 + initialIndex;
           consonants.push(String.fromCharCode(initialCode));
           
           // 종성 추출 (있는 경우)
           const finalIndex = syllableIndex % 28;
           if (finalIndex > 0) {
             const finalCode = 0x3131 + finalIndex - 1;
             consonants.push(String.fromCharCode(finalCode));
           }
         }
         // 자모에서 자음만 추출 (ㄱ-ㅎ: 3131-314E)
         else if (code >= 0x3131 && code <= 0x314E) {
           consonants.push(char);
         }
       }
       
       return consonants.join('');
     }

     let stream = null;
     let ocrWorker = null;
     let ocrInterval = null;
     let dbRows = [];

     // 선택 영역 상태
     let selecting = false;
     let selStart = {x:0,y:0};
     let selection = null; // {x,y,w,h}
     let dbIndex = new Map(); // 정규화된 col1 -> [col2, col2, ...]

     async function loadCSV() {
       try {
         setStatus('DB 불러오는 중...');
         const res = await fetch('database.csv');
         if (!res.ok) throw new Error(res.status + ' ' + res.statusText);
         const txt = await res.text();
         dbRows = txt.split(/\r?\n/).map(line => line.split(',').map(c => c.trim()));
         // 인덱스 생성: 정규화된 col1(자음만) -> array of col2
         dbIndex.clear();
         for (const r of dbRows) {
           if (!r || r.length < 2) continue;
           const k1 = normalizeKey(r[0] || '');
           const v2 = (r[1] || '').trim();
           if (!dbIndex.has(k1)) dbIndex.set(k1, []);
           dbIndex.get(k1).push(v2);
         }
         setStatus('DB 로드 완료: ' + dbRows.length + '행, 자음 인덱스:' + dbIndex.size);
         log('DB 자음 인덱스 예시: ' + JSON.stringify(Array.from(dbIndex.entries()).slice(0,5)));
       } catch (e) {
         setStatus('DB 로드 실패: ' + e.message);
         log('loadCSV error: ' + e.stack);
       }
     }

     async function startOCR() {
       try {
         if (!window.Tesseract) {
           setStatus('Tesseract 로더를 찾을 수 없습니다.');
           return;
         }
         log('Tesseract 객체 타입: ' + typeof Tesseract + ', keys: ' + Object.keys(Tesseract || {}).join(', '));
         if (!ocrWorker) {
           setStatus('OCR 워커 생성 중...');
           // 안전하게 createWorker 사용 시도 (logger는 과다 출력 억제)
           try {
             const tessLogger = makeTesseractLogger('tesseract');
             if (typeof Tesseract.createWorker === 'function') {
               // langPath를 지정하여 tessdata_best / tessdata_fast의 kor.traineddata를 사용
               ocrWorker = Tesseract.createWorker({ logger: tessLogger, langPath: TESSDATA_BASE });
                if (typeof ocrWorker.then === 'function') {
                  log('createWorker returned a promise; awaiting it');
                  ocrWorker = await ocrWorker;
                }
                if (typeof ocrWorker.load === 'function') {
                  await ocrWorker.load();
                  setStatus('OCR: load 완료');
                  // kor 훈련 데이터 로드 (지정한 langPath에서 kor.traineddata 가져옴)
                  await ocrWorker.loadLanguage('kor');
                  setStatus('OCR: 언어 로드 완료 (kor)');
                  await ocrWorker.initialize('kor');
                  setStatus('OCR: 초기화 완료');
                  setProgress(0);
                  // 워커 초기화 후 인식 정확도 개선을 위한 파라미터 설정 시도
                  try {
                    if (typeof ocrWorker.setParameters === 'function') {
                      // PSM: 7 = treat image as a single text line (선택영역이 한 줄이면 효과적)
                      await ocrWorker.setParameters({ tessedit_pageseg_mode: '7' });
                      log('OCR 파라미터 설정: PSM=7');
                    }
                  } catch (e) {
                    log('setParameters 지원 안됨 또는 실패: ' + (e && e.message));
                  }
                  return;
                } else {
                  log('ocrWorker.load 없음 -> fallback 모드로 전환');
                }
              } else {
                log('Tesseract.createWorker 미지원 -> fallback 모드로 전환');
              }
           } catch (e) {
             log('createWorker 에러: ' + (e && e.message));
             // 계속해서 fallback으로 처리
           }

           // fallback: createWorker 사용 불가할 때 Tesseract.recognize를 직접 사용하는 래퍼
           const fallbackLogger = makeTesseractLogger('tesseract(fallback)');
           ocrWorker = {
             _fallback: true,
             recognize: (img) => {
               // fallback에서도 가능한 경우 langPath를 지정하여 kor.traineddata를 사용 시도
               return Tesseract.recognize(img, 'kor', { logger: fallbackLogger, langPath: TESSDATA_BASE });
             },
             terminate: () => {
               log('fallback ocrWorker terminate 호출');
             }
           };
           setStatus('OCR: fallback 준비 완료');
         }
       } catch (e) {
         setStatus('OCR 초기화 실패: ' + e.message);
         log('OCR init error: ' + e.stack);
         ocrWorker = null;
       }
     }

     // overlay 크기 동기화
     function fitOverlayToVideo() {
       const rect = video.getBoundingClientRect();
       overlay.width = Math.round(rect.width);
       overlay.height = Math.round(rect.height);
       overlay.style.width = rect.width + 'px';
       overlay.style.height = rect.height + 'px';
       drawSelection();
     }

     function drawSelection() {
       const ctx = overlay.getContext('2d');
       ctx.clearRect(0,0,overlay.width, overlay.height);
       if (selection) {
         ctx.fillStyle = 'rgba(0,0,0,0.35)';
         ctx.fillRect(0,0,overlay.width, overlay.height);
         ctx.clearRect(selection.x, selection.y, selection.w, selection.h);
         ctx.strokeStyle = '#ff0';
         ctx.lineWidth = 2;
         ctx.strokeRect(selection.x + 0.5, selection.y + 0.5, selection.w, selection.h);
       }
     }

     overlay.addEventListener('mousedown', (e) => {
       selecting = true;
       const rect = overlay.getBoundingClientRect();
       selStart.x = e.clientX - rect.left;
       selStart.y = e.clientY - rect.top;
       selection = { x: selStart.x, y: selStart.y, w: 0, h: 0 };
       drawSelection();
     });
     window.addEventListener('mousemove', (e) => {
       if (!selecting) return;
       const rect = overlay.getBoundingClientRect();
       const cx = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
       const cy = Math.max(0, Math.min(rect.height, e.clientY - rect.top));
       const x = Math.min(selStart.x, cx);
       const y = Math.min(selStart.y, cy);
       const w = Math.abs(cx - selStart.x);
       const h = Math.abs(cy - selStart.y);
       selection = { x: Math.round(x), y: Math.round(y), w: Math.round(w), h: Math.round(h) };
       drawSelection();
     });
     window.addEventListener('mouseup', () => {
       if (!selecting) return;
       selecting = false;
       if (selection && (selection.w === 0 || selection.h === 0)) selection = null;
       drawSelection();
       resetSelBtn.disabled = !selection;
       log('선택영역 지정됨: ' + JSON.stringify(selection));
     });

     resetSelBtn.addEventListener('click', () => {
       selection = null;
       drawSelection();
       resetSelBtn.disabled = true;
       log('선택영역 초기화');
     });

     // 이미지 전처리: 확대(해상도 증가), 그레이스케일, 대비 스트레칭, Otsu 이진화
     function preprocessCanvas(srcCanvas, scale = 4) {
       const w = Math.max(1, Math.round(srcCanvas.width * scale));
       const h = Math.max(1, Math.round(srcCanvas.height * scale));
       const c = document.createElement('canvas');
       c.width = w; c.height = h;
       const ctx = c.getContext('2d');
       ctx.imageSmoothingEnabled = false;
       ctx.drawImage(srcCanvas, 0, 0, w, h);

       const img = ctx.getImageData(0, 0, w, h);
       const data = img.data;

       // 그레이스케일 및 히스토그램 생성
       const hist = new Uint32Array(256);
       for (let i = 0; i < data.length; i += 4) {
         const r = data[i], g = data[i+1], b = data[i+2];
         const lum = Math.round(0.299*r + 0.587*g + 0.114*b);
         data[i] = data[i+1] = data[i+2] = lum;
         hist[lum]++;
       }

       // Otsu 임계값 계산
       let total = w * h;
       let sum = 0;
       for (let t = 0; t < 256; t++) sum += t * hist[t];
       let sumB = 0, wB = 0, maxVar = 0, threshold = 0;
       for (let t = 0; t < 256; t++) {
         wB += hist[t];
         if (wB === 0) continue;
         const wF = total - wB;
         if (wF === 0) break;
         sumB += t * hist[t];
         const mB = sumB / wB;
         const mF = (sum - sumB) / wF;
         const varBetween = wB * wF * (mB - mF) * (mB - mF);
         if (varBetween > maxVar) { maxVar = varBetween; threshold = t; }
       }

       // 대비 스트레칭 + 이진화
       for (let i = 0; i < data.length; i += 4) {
         let v = data[i];
         // 간단한 대비 보정: 중앙값 기준 약간 증가
         v = Math.round((v - threshold) * 1.15 + 128);
         v = v < 0 ? 0 : (v > 255 ? 255 : v);
         const bw = v >= threshold ? 255 : 0;
         data[i] = data[i+1] = data[i+2] = bw;
       }

       ctx.putImageData(img, 0, 0);
       return c;
     }

     async function doCaptureAndLookup() {
       try {
         if (!video.videoWidth || !video.videoHeight) return;
         const rect = video.getBoundingClientRect();
         const ctx = canvas.getContext('2d');

         if (selection) {
           // 선택 좌표를 비디오 원해상도에 매핑
           const scaleX = video.videoWidth / rect.width;
           const scaleY = video.videoHeight / rect.height;
           const sx = Math.round(selection.x * scaleX);
           const sy = Math.round(selection.y * scaleY);
           const sw = Math.round(selection.w * scaleX);
           const sh = Math.round(selection.h * scaleY);
           canvas.width = sw; canvas.height = sh;
           ctx.drawImage(video, sx, sy, sw, sh, 0, 0, sw, sh);
           log(`캡쳐: 선택영역 (${sx},${sy},${sw}x${sh})`);
         } else {
           canvas.width = video.videoWidth; canvas.height = video.videoHeight;
           ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
           log(`캡쳐: 전체 프레임 (${canvas.width}x${canvas.height})`);
         }

         if (!ocrWorker) {
           log('OCR 워커 미초기화, 초기화 시도...');
           await startOCR();
           if (!ocrWorker) {
             setStatus('OCR 워커 생성 실패');
             return;
           }
         }

         setStatus('OCR 인식 시작...');
         setProgress(0);
         // 전처리: 해상도 증가 및 이진화로 인식률 향상 (스케일 4로 확대)
         const procCanvas = preprocessCanvas(canvas, 4); // 4배 확대
         let res;
         try {
           res = await ocrWorker.recognize(procCanvas);
         } catch (e) {
           log('OCR 인식 실패: ' + (e && e.message));
           throw e;
         }
         // OCR 완료
         setStatus('OCR 완료');
         // OCR 원문 가져오기 (createWorker와 fallback 결과 인터페이스 차이 고려)
         const rawText = (res && (res.data && res.data.text)) ? res.data.text : (res && res.text ? res.text : '');
         // 실시간 표시영역에 간단히 출력 (로그는 간략하게만)
         liveTextEl.textContent = rawText.trim() || '(인식된 텍스트 없음)';
         log('OCR 원문(요약): ' + (rawText ? rawText.replace(/\s+/g,' ').slice(0,200) + (rawText.length>200? '…':'') : '(빈문자열)'));
         
         // 한글에서 자음만 추출하여 줄 단위로 분리
         const consonantExtracted = rawText.replace(/[^\u1100-\u11FF\u3130-\u318F\uAC00-\uD7A3\s]/g, '');
         const lines = consonantExtracted.split(/\r?\n/).map(s => s.trim()).filter(s => s);
         log('추출된 라인(한글만 필터): ' + JSON.stringify(lines.slice(0,5)));
         
         // 한 줄만 사용: 첫 줄(문제 텍스트)
         const raw1 = lines[0] || '';
         // normalizeKey에서 자음만 추출하므로 "안녕하세요" -> "ㅇㄴㄴㅇㅎㅅㅇ"로 변환됨
         const key1 = normalizeKey(raw1);
         log(`정규화 키(자음 추출): [${raw1} -> ${key1}]`);

         // 1열 기준으로 모든 2열값을 조회 (자음 기준 매칭)
         const matches = dbIndex.get(key1) || [];
         if (matches.length > 0) {
           setStatus('DB 일치 항목 발견: ' + matches.length + '개');
           log('DB 매칭(자음 기준): ' + key1 + ' -> ' + JSON.stringify(matches));
           renderResults(matches);
         } else {
           setStatus('DB 매칭 없음');
           log('DB 매칭 없음 (자음키=' + key1 + ')');
           renderResults([]);
         }
       } catch (e) {
         setStatus('doCapture 에러: ' + e.message);
         log('doCapture 에러: ' + e.stack);
       }
     }

     startBtn.addEventListener('click', async () => {
       try {
         await loadCSV();
         await startOCR();

         setStatus('화면 공유 권한 요청...');
         stream = await navigator.mediaDevices.getDisplayMedia({ video: true });
         video.srcObject = stream;
         previewWrap.style.display = 'inline-block';

         video.addEventListener('loadedmetadata', () => {
           setTimeout(() => {
             fitOverlayToVideo();
             log('비디오 메타데이터 로드: ' + video.videoWidth + 'x' + video.videoHeight);
           }, 50);
         });
         window.addEventListener('resize', fitOverlayToVideo);

         startBtn.disabled = true;
         stopBtn.disabled = false;
         status.textContent = '화면 공유 중... OCR 실행 중';
         resetSelBtn.disabled = true;

         // 빠른 디버깅을 위해 1초 간격으로 캡쳐+OCR, 필요시 늘릴 것
         ocrInterval = setInterval(() => {
           doCaptureAndLookup().catch(e => console.error(e));
         }, 1000);

         log('주기적 OCR 시작 (1초)');
       } catch (e) {
         setStatus('시작 실패: ' + e.message);
         log('startBtn 에러: ' + e.stack);
       }
     });

     stopBtn.addEventListener('click', () => {
       if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
       if (ocrInterval) { clearInterval(ocrInterval); ocrInterval = null; }
       startBtn.disabled = false;
       stopBtn.disabled = true;
       setStatus('중지됨');
       previewWrap.style.display = 'none';
       selection = null;
       drawSelection();
       log('화면 공유 중지 및 리소스 해제');
     });

     // 결과 렌더링: 배열을 받아 각 항목별 복사 버튼 생성
     function renderResults(list) {
       resultDiv.innerHTML = ''; // 초기화
       if (!list || list.length === 0) {
         resultDiv.textContent = '데이터베이스에서 일치 항목 없음';
         copyBtn.disabled = true;
         return;
       }
       const ul = document.createElement('div');
       ul.style.display = 'flex';
       ul.style.flexDirection = 'column';
       ul.style.gap = '6px';
       list.forEach((val, idx) => {
         const row = document.createElement('div');
         row.style.display = 'flex';
         row.style.alignItems = 'center';
         row.style.gap = '8px';

         const txt = document.createElement('span');
         txt.textContent = val;
         txt.style.padding = '6px 8px';
         txt.style.border = '1px solid #ddd';
         txt.style.borderRadius = '4px';
         txt.style.background = '#f9f9f9';

         const btn = document.createElement('button');
         btn.textContent = '복사';
         btn.addEventListener('click', async () => {
           try {
             await navigator.clipboard.writeText(val);
             setStatus(`클립보드에 복사됨: "${val}"`);
             log(`항목 복사: ${val}`);
           } catch (e) {
             setStatus('복사 실패: ' + e.message);
             log('copy error: ' + e.stack);
           }
         });

         row.appendChild(txt);
         row.appendChild(btn);
         ul.appendChild(row);
       });
       resultDiv.appendChild(ul);
       copyBtn.disabled = true; // 개별 버튼으로 복사하도록 전역 복사 버튼 비활성
     }

     window.addEventListener('beforeunload', async () => {
       try {
         if (stream) stream.getTracks().forEach(t => t.stop());
         if (ocrWorker) {
           if (typeof ocrWorker.terminate === 'function') {
             // createWorker의 terminate가 프로미스일 경우 await
             const term = ocrWorker.terminate();
             if (term && typeof term.then === 'function') await term;
           }
         }
       } catch (e) {
         log('종료 중 에러: ' + e.message);
       }
     });
  // 실시간 텍스트 복사 버튼 동작
  if (copyLiveBtn) {
    copyLiveBtn.addEventListener('click', async () => {
      try {
        const txt = (liveTextEl && liveTextEl.textContent) ? liveTextEl.textContent.trim() : '';
        if (!txt) { setStatus('복사할 실시간 텍스트 없음'); return; }
        await navigator.clipboard.writeText(txt);
        setStatus('실시간 텍스트 클립보드에 복사됨');
        log('실시간 텍스트 복사');
      } catch (e) {
        setStatus('실시간 복사 실패: ' + (e && e.message));
        log('copyLiveBtn error: ' + (e && e.stack));
      }
    });
  }
   </script>
 </body>
</html>