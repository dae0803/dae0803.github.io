<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>FindCho - 화면 OCR 및 DB 조회</title>
  <style>
    body{font-family: Arial, sans-serif; padding:16px}
    /* 레이아웃: 결과는 왼쪽, 미리보기는 오른쪽 */
    .mainWrap{display:flex; gap:16px; align-items:flex-start; margin-top:8px;}
    .leftCol{width:320px; min-width:240px;}
    .rightCol{flex:1; min-width:360px;}
    #previewWrap{position:relative; border:1px solid #ddd; margin-top:0;}
    video{display:block; width:100%; max-width:900px; max-height:720px; background:#999;}
     #overlay{position:absolute; left:0; top:0; cursor:crosshair;}
     #result{margin-top:12px; padding:8px; border:1px solid #ccc; min-height:28px}
     button{margin-right:8px}
     #hint{font-size:12px; color:#666}
     #log{white-space:pre-wrap; background:#111; color:#efe; padding:8px; margin-top:12px; max-height:180px; overflow:auto; font-size:12px}
     #progressWrap{margin-top:8px; width:100%; max-width:640px}
     #progress{width:100%; height:10px; background:#eee; border:1px solid #ccc}
     #progress > i{display:block; height:100%; width:0%; background:#4caf50}
   </style>
 </head>
 <body>
   <h3>화면 공유 → OCR → DB 조회 → 복사</h3>
  <div class="mainWrap">
    <div class="leftCol">
      <div class="controls" style="display:flex; flex-wrap:wrap; gap:6px;">
        <button id="startBtn">화면 공유 시작</button>
        <button id="stopBtn" disabled>중지</button>
        <button id="copyBtn" disabled>결과 복사</button>
        <button id="resetSelBtn" disabled>영역 초기화</button>
      </div>
      <div id="status" style="margin-top:8px">준비</div>
      <div id="result">결과가 여기에 표시됩니다.</div>
    </div>

    <div class="rightCol">
      <div id="previewWrap" style="display:none;">
        <video id="screenVideo" autoplay playsinline></video>
        <canvas id="overlay"></canvas>
      </div>

      <canvas id="capCanvas" style="display:none"></canvas>

      <div id="hint">비디오 위에서 드래그하여 캡쳐 영역을 지정하세요. 지정하지 않으면 전체 화면을 캡쳐합니다.</div>

      <div id="progressWrap">
        <div id="progress"><i></i></div>
      </div>

      <div id="log">실시간 로그가 여기에 표시됩니다.</div>
    </div>
  </div>

 <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
 <script>
   const startBtn = document.getElementById('startBtn');
   const stopBtn = document.getElementById('stopBtn');
   const copyBtn = document.getElementById('copyBtn');
   const resetSelBtn = document.getElementById('resetSelBtn');
   const status = document.getElementById('status');
   const resultDiv = document.getElementById('result');
   const video = document.getElementById('screenVideo');
   const overlay = document.getElementById('overlay');
   const previewWrap = document.getElementById('previewWrap');
   const canvas = document.getElementById('capCanvas');
   const logEl = document.getElementById('log');
   const progressBar = document.querySelector('#progress > i');
 
     // 상태/로그/프로그레스 유틸 (추가)
     function log(msg) {
       try {
         const time = new Date().toLocaleTimeString();
         logEl.textContent = `[${time}] ${msg}\n` + logEl.textContent;
       } catch (e) { console.log('log error', e); }
     }
 
     function setStatus(s) {
       try {
         status.textContent = s;
         log(s);
       } catch (e) { console.log('setStatus error', e); }
     }
 
     function setProgress(p) {
       try {
         const pct = Math.max(0, Math.min(1, Number(p) || 0));
         progressBar.style.width = Math.round(pct * 100) + '%';
       } catch (e) { console.log('setProgress error', e); }
     }
 
     // 텍스트 정규화: 공백 제거, 한글/자모/영숫자만 허용(소문자화)
     function normalizeKey(s) {
       if (!s) return '';
       let t = String(s).normalize('NFC');
       // 한글 외 문자 제거(숫자/영문도 보존하려면 범위에 추가)
       t = t.replace(/[^\u1100-\u11FF\u3130-\u318F\uAC00-\uD7A30-9a-zA-Z]/g, '');
       // 공백 제거(자모 사이에 생기는 공백 제거 목적)
       t = t.replace(/\s+/g, '');
       return t.toLowerCase();
     }
 
     let stream = null;
     let ocrWorker = null;
     let ocrInterval = null;
     let dbRows = [];
 
     // 선택 영역 상태
     let selecting = false;
     let selStart = {x:0,y:0};
     let selection = null; // {x,y,w,h}
     let dbIndex = new Map(); // 정규화된 col1 -> [col2, col2, ...]
 
     async function loadCSV() {
       try {
         setStatus('DB 불러오는 중...');
         const res = await fetch('database.csv');
         if (!res.ok) throw new Error(res.status + ' ' + res.statusText);
         const txt = await res.text();
         dbRows = txt.split(/\r?\n/).map(line => line.split(',').map(c => c.trim()));
         // 인덱스 생성: 정규화된 col1 -> array of col2
         dbIndex.clear();
         for (const r of dbRows) {
           if (!r || r.length < 2) continue;
           const k1 = normalizeKey(r[0] || '');
           const v2 = (r[1] || '').trim();
           if (!dbIndex.has(k1)) dbIndex.set(k1, []);
           dbIndex.get(k1).push(v2);
         }
         setStatus('DB 로드 완료: ' + dbRows.length + '행, 인덱스:' + dbIndex.size);
         log('DB 인덱스 예시: ' + JSON.stringify(Array.from(dbIndex.entries()).slice(0,5)));
       } catch (e) {
         setStatus('DB 로드 실패: ' + e.message);
         log('loadCSV error: ' + e.stack);
       }
     }
 
     async function startOCR() {
       try {
         if (!window.Tesseract) {
           setStatus('Tesseract 로더를 찾을 수 없습니다.');
           return;
         }
         log('Tesseract 객체 타입: ' + typeof Tesseract + ', keys: ' + Object.keys(Tesseract || {}).join(', '));
         if (!ocrWorker) {
           setStatus('OCR 워커 생성 중...');
           // 안전하게 createWorker 사용 시도
           try {
             if (typeof Tesseract.createWorker === 'function') {
               ocrWorker = Tesseract.createWorker({
                 logger: m => {
                   log('tesseract: ' + (m.status || '') + ' ' + (m.progress ? (Math.round(m.progress*100)+'%') : ''));
                   if (typeof m.progress === 'number') setProgress(m.progress);
                 }
               });
               // 일부 환경에서 createWorker가 프로미스를 반환할 가능성을 방어
               if (typeof ocrWorker.then === 'function') {
                 log('createWorker returned a promise; awaiting it');
                 ocrWorker = await ocrWorker;
               }
               log('ocrWorker keys: ' + Object.keys(ocrWorker || {}).join(', '));
               if (typeof ocrWorker.load === 'function') {
                 await ocrWorker.load();
                 setStatus('OCR: load 완료');
                 // 한글 전용으로 설정하여 영어 인식으로 인한 잡음 최소화
                 await ocrWorker.loadLanguage('kor');
                 setStatus('OCR: 언어 로드 완료 (kor)');
                 await ocrWorker.initialize('kor');
                 setStatus('OCR: 초기화 완료');
                 setProgress(0);
                 return;
               } else {
                 log('ocrWorker.load 없음 -> fallback 모드로 전환');
               }
             } else {
               log('Tesseract.createWorker 미지원 -> fallback 모드로 전환');
             }
           } catch (e) {
             log('createWorker 에러: ' + (e && e.message));
             // 계속해서 fallback으로 처리
           }
 
           // fallback: createWorker 사용 불가할 때 Tesseract.recognize를 직접 사용하는 래퍼
           const fallbackLogger = m => {
             log('tesseract(fallback): ' + (m.status || '') + ' ' + (m.progress ? (Math.round(m.progress*100)+'%') : ''));
             if (typeof m.progress === 'number') setProgress(m.progress);
           };
           ocrWorker = {
             _fallback: true,
             recognize: (img) => {
               // 한글 전용으로 인식하도록 'kor' 사용
               return Tesseract.recognize(img, 'kor', { logger: fallbackLogger });
             },
             terminate: () => {
               log('fallback ocrWorker terminate 호출');
             }
           };
           setStatus('OCR: fallback 준비 완료');
         }
       } catch (e) {
         setStatus('OCR 초기화 실패: ' + e.message);
         log('OCR init error: ' + e.stack);
         ocrWorker = null;
       }
     }
 
     // overlay 크기 동기화
     function fitOverlayToVideo() {
       const rect = video.getBoundingClientRect();
       overlay.width = Math.round(rect.width);
       overlay.height = Math.round(rect.height);
       overlay.style.width = rect.width + 'px';
       overlay.style.height = rect.height + 'px';
       drawSelection();
     }
 
     function drawSelection() {
       const ctx = overlay.getContext('2d');
       ctx.clearRect(0,0,overlay.width, overlay.height);
       if (selection) {
         ctx.fillStyle = 'rgba(0,0,0,0.35)';
         ctx.fillRect(0,0,overlay.width, overlay.height);
         ctx.clearRect(selection.x, selection.y, selection.w, selection.h);
         ctx.strokeStyle = '#ff0';
         ctx.lineWidth = 2;
         ctx.strokeRect(selection.x + 0.5, selection.y + 0.5, selection.w, selection.h);
       }
     }
 
     overlay.addEventListener('mousedown', (e) => {
       selecting = true;
       const rect = overlay.getBoundingClientRect();
       selStart.x = e.clientX - rect.left;
       selStart.y = e.clientY - rect.top;
       selection = { x: selStart.x, y: selStart.y, w: 0, h: 0 };
       drawSelection();
     });
     window.addEventListener('mousemove', (e) => {
       if (!selecting) return;
       const rect = overlay.getBoundingClientRect();
       const cx = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
       const cy = Math.max(0, Math.min(rect.height, e.clientY - rect.top));
       const x = Math.min(selStart.x, cx);
       const y = Math.min(selStart.y, cy);
       const w = Math.abs(cx - selStart.x);
       const h = Math.abs(cy - selStart.y);
       selection = { x: Math.round(x), y: Math.round(y), w: Math.round(w), h: Math.round(h) };
       drawSelection();
     });
     window.addEventListener('mouseup', () => {
       if (!selecting) return;
       selecting = false;
       if (selection && (selection.w === 0 || selection.h === 0)) selection = null;
       drawSelection();
       resetSelBtn.disabled = !selection;
       log('선택영역 지정됨: ' + JSON.stringify(selection));
     });
 
     resetSelBtn.addEventListener('click', () => {
       selection = null;
       drawSelection();
       resetSelBtn.disabled = true;
       log('선택영역 초기화');
     });
 
     async function doCaptureAndLookup() {
       try {
         if (!video.videoWidth || !video.videoHeight) return;
         const rect = video.getBoundingClientRect();
         const ctx = canvas.getContext('2d');
 
         if (selection) {
           const scaleX = video.videoWidth / rect.width;
           const scaleY = video.videoHeight / rect.height;
           const sx = Math.round(selection.x * scaleX);
           const sy = Math.round(selection.y * scaleY);
           const sw = Math.round(selection.w * scaleX);
           const sh = Math.round(selection.h * scaleY);
           if (sw <= 0 || sh <= 0) return;
           canvas.width = sw; canvas.height = sh;
           ctx.drawImage(video, sx, sy, sw, sh, 0, 0, sw, sh);
           log(`캡쳐: 선택영역 (${sx},${sy},${sw}x${sh})`);
         } else {
           canvas.width = video.videoWidth; canvas.height = video.videoHeight;
           ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
           log(`캡쳐: 전체 프레임 (${canvas.width}x${canvas.height})`);
         }
 
         if (!ocrWorker) {
           log('OCR 워커 미초기화, 초기화 시도...');
           await startOCR();
           if (!ocrWorker) {
             setStatus('OCR 워커 생성 실패');
             return;
           }
         }
 
         setStatus('OCR 인식 시작...');
         setProgress(0);
         let res;
         try {
           res = await ocrWorker.recognize(canvas);
         } catch (e) {
           setStatus('OCR 실패: ' + e.message);
           log('recognize error: ' + e.stack);
           return;
         }
         // OCR 완료
         setStatus('OCR 완료');
         // OCR 원문 가져오기 (createWorker와 fallback 결과 인터페이스 차이 고려)
         const rawText = (res && (res.data && res.data.text)) ? res.data.text : (res && res.text ? res.text : '');
         log('OCR 원문:\n' + rawText);
         // 한글 외 문자 제거(영문/기호/숫자 등 제거) 및 줄 단위로 분리
         const hangulOnly = rawText.replace(/[^\u1100-\u11FF\u3130-\u318F\uAC00-\uD7A3\s]/g, '');
         const lines = hangulOnly.split(/\r?\n/).map(s => s.trim()).filter(s => s);
         log('추출된 라인(한글만 필터): ' + JSON.stringify(lines.slice(0,5)));
         // 한 줄만 사용: 첫 줄(문제 텍스트)
         const raw1 = lines[0] || '';
         // normalizeKey에서 공백 제거하므로 "ㅋ ㅅ ㅅ" -> "ㅋㅅㅅ"로 변환됨
         const key1 = normalizeKey(raw1);
         log(`정규화 키(1열 기준): [${raw1} -> ${key1}]`);
 
         // 1열 기준으로 모든 2열값을 조회
         const matches = dbIndex.get(key1) || [];
         if (matches.length > 0) {
           setStatus('DB 일치 항목 발견: ' + matches.length + '개');
           log('DB 매칭(1열 기준): ' + key1 + ' -> ' + JSON.stringify(matches));
           renderResults(matches);
         } else {
           setStatus('DB 매칭 없음');
           log('DB 매칭 없음 (key1=' + key1 + ')');
           renderResults([]);
         }
       } catch (e) {
         setStatus('doCapture 에러: ' + e.message);
         log('doCapture 에러: ' + e.stack);
       }
     }
 
     startBtn.addEventListener('click', async () => {
       try {
         await loadCSV();
         await startOCR();
 
         setStatus('화면 공유 권한 요청...');
         stream = await navigator.mediaDevices.getDisplayMedia({ video: true });
         video.srcObject = stream;
         previewWrap.style.display = 'inline-block';
 
         video.addEventListener('loadedmetadata', () => {
           setTimeout(() => {
             fitOverlayToVideo();
             log('비디오 메타데이터 로드: ' + video.videoWidth + 'x' + video.videoHeight);
           }, 50);
         });
         window.addEventListener('resize', fitOverlayToVideo);
 
         startBtn.disabled = true;
         stopBtn.disabled = false;
         status.textContent = '화면 공유 중... OCR 실행 중';
         resetSelBtn.disabled = true;
 
         // 빠른 디버깅을 위해 1초 간격으로 캡쳐+OCR, 필요시 늘릴 것
         ocrInterval = setInterval(() => {
           doCaptureAndLookup().catch(e => console.error(e));
         }, 1000);
 
         log('주기적 OCR 시작 (1초)');
       } catch (e) {
         setStatus('시작 실패: ' + e.message);
         log('startBtn 에러: ' + e.stack);
       }
     });
 
     stopBtn.addEventListener('click', () => {
       if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
       if (ocrInterval) { clearInterval(ocrInterval); ocrInterval = null; }
       startBtn.disabled = false;
       stopBtn.disabled = true;
       setStatus('중지됨');
       previewWrap.style.display = 'none';
       selection = null;
       drawSelection();
       log('화면 공유 중지 및 리소스 해제');
     });
 
     // 결과 렌더링: 배열을 받아 각 항목별 복사 버튼 생성
     function renderResults(list) {
       resultDiv.innerHTML = ''; // 초기화
       if (!list || list.length === 0) {
         resultDiv.textContent = '데이터베이스에서 일치 항목 없음';
         copyBtn.disabled = true;
         return;
       }
       const ul = document.createElement('div');
       ul.style.display = 'flex';
       ul.style.flexDirection = 'column';
       ul.style.gap = '6px';
       list.forEach((val, idx) => {
         const row = document.createElement('div');
         row.style.display = 'flex';
         row.style.alignItems = 'center';
         row.style.gap = '8px';
 
         const txt = document.createElement('span');
         txt.textContent = val;
         txt.style.padding = '6px 8px';
         txt.style.border = '1px solid #ddd';
         txt.style.borderRadius = '4px';
         txt.style.background = '#f9f9f9';
 
         const btn = document.createElement('button');
         btn.textContent = '복사';
         btn.addEventListener('click', async () => {
           try {
             await navigator.clipboard.writeText(val);
             setStatus(`클립보드에 복사됨: "${val}"`);
             log(`항목 복사: ${val}`);
           } catch (e) {
             setStatus('복사 실패: ' + e.message);
             log('copy error: ' + e.stack);
           }
         });
 
         row.appendChild(txt);
         row.appendChild(btn);
         ul.appendChild(row);
       });
       resultDiv.appendChild(ul);
       copyBtn.disabled = true; // 개별 버튼으로 복사하도록 전역 복사 버튼 비활성
     }
 
     window.addEventListener('beforeunload', async () => {
       try {
         if (stream) stream.getTracks().forEach(t => t.stop());
         if (ocrWorker) {
           if (typeof ocrWorker.terminate === 'function') {
             // createWorker의 terminate가 프로미스일 경우 await
             const term = ocrWorker.terminate();
             if (term && typeof term.then === 'function') await term;
           }
         }
       } catch (e) {
         log('종료 중 에러: ' + e.message);
       }
     });
   </script>
 </body>
</html>