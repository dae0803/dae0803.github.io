<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>FindCho - 화면 OCR 및 DB 조회</title>
  <style>
    body{font-family: Arial, sans-serif; padding:16px}
    /* 레이아웃: 결과는 왼쪽, 미리보기는 오른쪽 */
    .mainWrap{display:flex; gap:16px; align-items:flex-start; margin-top:8px;}
    .leftCol{width:320px; min-width:240px;}
    .rightCol{flex:1; min-width:360px;}
    #previewWrap{position:relative; border:1px solid #ddd; margin-top:0;}
    video{display:block; width:100%; max-width:900px; max-height:720px; background:#999;}
    #overlay{position:absolute; left:0; top:0; cursor:crosshair;}
    #result{margin-top:12px; padding:8px; border:1px solid #ccc; min-height:28px}
    button{margin-right:8px}
    #hint{font-size:12px; color:#666}
    #log{white-space:pre-wrap; background:#111; color:#efe; padding:8px; margin-top:12px; max-height:180px; overflow:auto; font-size:12px}
    #progressWrap{margin-top:8px; width:100%; max-width:640px}
    #progress{width:100%; height:10px; background:#eee; border:1px solid #ccc}
    #progress > i{display:block; height:100%; width:0%; background:#4caf50}
    /* 실시간 OCR 텍스트 표시창 (간단) */
    #ocrLive { margin-top:8px; padding:6px; border:1px dashed #9c9; min-height:48px; background:#f6fff6; font-size:14px; white-space:pre-wrap; overflow:auto; display:flex; gap:8px; align-items:flex-start; }
    #ocrLiveText { flex:1; white-space:pre-wrap; word-break:break-word; }
    #copyLiveBtn { flex:0 0 auto; padding:6px 8px; font-size:12px; cursor:pointer; }
   </style>
   <!-- head 안에 OpenCV 로더 추가 (원하면 async로 바꿔도 됨) -->
   <script src="https://docs.opencv.org/4.x/opencv.js"></script>
   <!-- head 안에 TensorFlow.js 추가 -->
   <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0/dist/tf.min.js"></script>
 </head>
 <body>
   <h3>화면 공유 → OCR → DB 조회 → 복사</h3>
  <div class="mainWrap">
    <div class="leftCol">
      <div class="controls" style="display:flex; flex-wrap:wrap; gap:6px;">
        <button id="startBtn">화면 공유 시작</button>
        <button id="stopBtn" disabled>중지</button>
        <button id="copyBtn" disabled>결과 복사</button>
        <button id="resetSelBtn" disabled>영역 초기화</button>
      </div>
      <div id="status" style="margin-top:8px">준비</div>
      <div id="ocrLive">
        <div id="ocrLiveText">실시간 인식 텍스트가 여기에 표시됩니다.</div>
        <button id="copyLiveBtn">실시간 복사</button>
      </div>
      <div id="result">결과가 여기에 표시됩니다.</div>
    </div>

    <div class="rightCol">
      <div id="previewWrap" style="display:none;">
        <video id="screenVideo" autoplay playsinline></video>
        <canvas id="overlay"></canvas>
      </div>

      <canvas id="capCanvas" style="display:none"></canvas>

      <div id="hint">비디오 위에서 드래그하여 캡쳐 영역을 지정하세요. 지정하지 않으면 전체 화면을 캡쳐합니다.</div>

      <div id="progressWrap">
        <div id="progress"><i></i></div>
      </div>

      <div id="log">실시간 로그가 여기에 표시됩니다.</div>
    </div>
  </div>

 <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
 <script>
   const startBtn = document.getElementById('startBtn');
   const stopBtn = document.getElementById('stopBtn');
   const copyBtn = document.getElementById('copyBtn');
   const resetSelBtn = document.getElementById('resetSelBtn');
   const status = document.getElementById('status');
   const resultDiv = document.getElementById('result');
   const liveTextEl = document.getElementById('ocrLiveText');
   const copyLiveBtn = document.getElementById('copyLiveBtn');
   const video = document.getElementById('screenVideo');
   const overlay = document.getElementById('overlay');
   const previewWrap = document.getElementById('previewWrap');
   const canvas = document.getElementById('capCanvas');
   const logEl = document.getElementById('log');
   const progressBar = document.querySelector('#progress > i');
   // Tesseract tessdata 선택: 'tessdata_fast' 또는 'tessdata_best' (크기·정확도 차이)
   const TESSDATA_VARIANT = 'tessdata_best'; // 혹은 'tessdata_fast'
   const TESSDATA_BASE = `https://cdn.jsdelivr.net/gh/tesseract-ocr/${TESSDATA_VARIANT}@main`;

     // 상태/로그/프로그레스 유틸 (추가)
     function log(msg) {
       try {
         const time = new Date().toLocaleTimeString();
         logEl.textContent = `[${time}] ${msg}\n` + logEl.textContent;
       } catch (e) { console.log('log error', e); }
     }

     function setStatus(s) {
       try {
         status.textContent = s;
         log(s);
       } catch (e) { console.log('setStatus error', e); }
     }

     function setProgress(p) {
       try {
         const pct = Math.max(0, Math.min(1, Number(p) || 0));
         progressBar.style.width = Math.round(pct * 100) + '%';
       } catch (e) { console.log('setProgress error', e); }
     }

    // Tesseract 로그 출력 과다 문제를 완화하기 위한 throttle logger
    let _tessLastStatus = '';
    let _tessLastProgress = -1;
    function makeTesseractLogger(prefix = 'tesseract') {
      return function(m) {
        try {
          const status = m && m.status ? String(m.status) : '';
          const progress = (typeof m.progress === 'number') ? m.progress : null;
          // 상태가 바뀌었을 때만 로그 (상태별로 한 번)
          if (status && status !== _tessLastStatus) {
            _tessLastStatus = status;
            log(`${prefix}: ${status}`);
          }
          // 진행률은 5% 단위로만 갱신
          if (progress !== null) {
            const step = 0.05;
            const clamped = Math.min(1, Math.max(0, progress));
            if (_tessLastProgress < 0 || clamped - _tessLastProgress >= step || clamped === 1) {
              _tessLastProgress = clamped;
              setProgress(clamped);
              log(`${prefix}: progress ${(Math.round(clamped*100))}%`);
            }
          }
        } catch (e) {
          // 무시
        }
      };
    }

     // 텍스트 정규화: 한글 자음만 추출
     function normalizeKey(s) {
       if (!s) return '';
       let t = String(s).normalize('NFC');
       
       // 한글 자음 유니코드 범위 (ㄱ-ㅎ): \u3131-\u314E
       const consonants = [];
       
       for (let i = 0; i < t.length; i++) {
         const char = t[i];
         const code = char.charCodeAt(0);
         
         // 완성된 한글에서 자음 추출 (가-힣: AC00-D7A3)
         if (code >= 0xAC00 && code <= 0xD7A3) {
           const syllableIndex = code - 0xAC00;
           // 초성 추출
           const initialIndex = Math.floor(syllableIndex / 588);
           const initialCode = 0x3131 + initialIndex;
           consonants.push(String.fromCharCode(initialCode));
           
           // 종성 추 extract (있는 경우)
           const finalIndex = syllableIndex % 28;
           if (finalIndex > 0) {
             const finalCode = 0x3131 + finalIndex - 1;
             consonants.push(String.fromCharCode(finalCode));
           }
         }
         // 자모에서 자음만 추출 (ㄱ-ㅎ: 3131-314E)
         else if (code >= 0x3131 && code <= 0x314E) {
           consonants.push(char);
         }
       }
       
       return consonants.join('');
     }

     let stream = null;
     let ocrWorker = null;
     let ocrInterval = null;
     let dbRows = [];

     // 선택 영역 상태
     let selecting = false;
     let selStart = {x:0,y:0};
     let selection = null; // {x,y,w,h}
     let dbIndex = new Map(); // 정규화된 col1 -> [col2, col2, ...]

     async function loadCSV() {
       try {
         setStatus('DB 불러오는 중...');
         const res = await fetch('database.csv');
         if (!res.ok) throw new Error(res.status + ' ' + res.statusText);
         const txt = await res.text();
         dbRows = txt.split(/\r?\n/).map(line => line.split(',').map(c => c.trim()));
         // 인덱스 생성: 정규화된 col1(자음만) -> array of col2
         dbIndex.clear();
         for (const r of dbRows) {
           if (!r || r.length < 2) continue;
           const k1 = normalizeKey(r[0] || '');
           const v2 = (r[1] || '').trim();
           if (!dbIndex.has(k1)) dbIndex.set(k1, []);
           dbIndex.get(k1).push(v2);
         }
         setStatus('DB 로드 완료: ' + dbRows.length + '행, 자음 인덱스:' + dbIndex.size);
         log('DB 자음 인덱스 예시: ' + JSON.stringify(Array.from(dbIndex.entries()).slice(0,5)));
       } catch (e) {
         setStatus('DB 로드 실패: ' + e.message);
         log('loadCSV error: ' + e.stack);
       }
     }

     async function startOCR() {
       try {
         if (!window.Tesseract) {
           setStatus('Tesseract 로더를 찾을 수 없습니다.');
           return;
         }
         log('Tesseract 객체 타입: ' + typeof Tesseract + ', keys: ' + Object.keys(Tesseract || {}).join(', '));
         if (!ocrWorker) {
           setStatus('OCR 워커 생성 중...');
           // 안전하게 createWorker 사용 시도 (logger는 과다 출력 억제)
           try {
             const tessLogger = makeTesseractLogger('tesseract');
             if (typeof Tesseract.createWorker === 'function') {
               // langPath를 지정하여 tessdata_best / tessdata_fast의 kor.traineddata를 사용
               ocrWorker = Tesseract.createWorker({ logger: tessLogger, langPath: TESSDATA_BASE });
                if (typeof ocrWorker.then === 'function') {
                  log('createWorker returned a promise; awaiting it');
                  ocrWorker = await ocrWorker;
                }
                if (typeof ocrWorker.load === 'function') {
                  await ocrWorker.load();
                  setStatus('OCR: load 완료');
                  // kor 훈련 데이터 로드 (지정한 langPath에서 kor.traineddata 가져옴)
                  await ocrWorker.loadLanguage('kor');
                  setStatus('OCR: 언어 로드 완료 (kor)');
                  await ocrWorker.initialize('kor');
                  setStatus('OCR: 초기화 완료');
                  setProgress(0);
                  // 워커 초기화 후 인식 정확도 개선을 위한 파라미터 설정 시도
                  try {
                    if (typeof ocrWorker.setParameters === 'function') {
                      // 한줄 자음 전용 최적화:
                      // - PSM: 7 (single text line)
                      // - whitelist: 한글 자음만 허용 (공백 포함)
                      await ocrWorker.setParameters({
                        tessedit_pageseg_mode: '7',
                        tessedit_char_whitelist: 'ㄱㄲㄴㄷㄸㄹㅁㅂㅃㅅㅆㅇㅈㅉㅊㅋㅌㅍㅎ '
                      });
                      log('OCR 파라미터 설정: PSM=7, whitelist(한글 자음) 적용');
                    }
                  } catch (e) {
                    log('setParameters 지원 안됨 또는 실패: ' + (e && e.message));
                  }
                  return;
                } else {
                  log('ocrWorker.load 없음 -> fallback 모드로 전환');
                }
              } else {
                log('Tesseract.createWorker 미지원 -> fallback 모드로 전환');
              }
           } catch (e) {
             log('createWorker 에러: ' + (e && e.message));
             // 계속해서 fallback으로 처리
           }

           // fallback: createWorker 사용 불가할 때 Tesseract.recognize를 직접 사용하는 래퍼
           const fallbackLogger = makeTesseractLogger('tesseract(fallback)');
           ocrWorker = {
             _fallback: true,
             recognize: (img) => {
               // fallback에서도 가능한 경우 langPath를 지정하여 kor.traineddata를 사용 시도
               return Tesseract.recognize(img, 'kor', { logger: fallbackLogger, langPath: TESSDATA_BASE });
             },
             terminate: () => {
               log('fallback ocrWorker terminate 호출');
             }
           };
           setStatus('OCR: fallback 준비 완료');
         }
       } catch (e) {
         setStatus('OCR 초기화 실패: ' + e.message);
         log('OCR init error: ' + e.stack);
         ocrWorker = null;
       }
     }

     // overlay 크기 동기화
     function fitOverlayToVideo() {
       const rect = video.getBoundingClientRect();
       overlay.width = Math.round(rect.width);
       overlay.height = Math.round(rect.height);
       overlay.style.width = rect.width + 'px';
       overlay.style.height = rect.height + 'px';
       drawSelection();
     }

     function drawSelection() {
       const ctx = overlay.getContext('2d');
       ctx.clearRect(0,0,overlay.width, overlay.height);
       if (selection) {
         ctx.fillStyle = 'rgba(0,0,0,0.35)';
         ctx.fillRect(0,0,overlay.width, overlay.height);
         ctx.clearRect(selection.x, selection.y, selection.w, selection.h);
         ctx.strokeStyle = '#ff0';
         ctx.lineWidth = 2;
         ctx.strokeRect(selection.x + 0.5, selection.y + 0.5, selection.w, selection.h);
       }
     }

     overlay.addEventListener('mousedown', (e) => {
       selecting = true;
       const rect = overlay.getBoundingClientRect();
       selStart.x = e.clientX - rect.left;
       selStart.y = e.clientY - rect.top;
       selection = { x: selStart.x, y: selStart.y, w: 0, h: 0 };
       drawSelection();
     });
     window.addEventListener('mousemove', (e) => {
       if (!selecting) return;
       const rect = overlay.getBoundingClientRect();
       const cx = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
       const cy = Math.max(0, Math.min(rect.height, e.clientY - rect.top));
       const x = Math.min(selStart.x, cx);
       const y = Math.min(selStart.y, cy);
       const w = Math.abs(cx - selStart.x);
       const h = Math.abs(cy - selStart.y);
       selection = { x: Math.round(x), y: Math.round(y), w: Math.round(w), h: Math.round(h) };
       drawSelection();
     });
     window.addEventListener('mouseup', () => {
       if (!selecting) return;
       selecting = false;
       if (selection && (selection.w === 0 || selection.h === 0)) selection = null;
       drawSelection();
       resetSelBtn.disabled = !selection;
       log('선택영역 지정됨: ' + JSON.stringify(selection));
     });

     resetSelBtn.addEventListener('click', () => {
       selection = null;
       drawSelection();
       resetSelBtn.disabled = true;
       log('선택영역 초기화');
     });

     // 이미지 전처리: OpenCV 사용 가능하면 adaptiveThreshold+morphology, 아니면 JS fallback(확대->이진->dilate->despeckle)
     function preprocessCanvas(srcCanvas, scale = 6, debugPreview = false) {
       const w = Math.max(1, Math.round(srcCanvas.width * scale));
       const h = Math.max(1, Math.round(srcCanvas.height * scale));
       const outCanvas = document.createElement('canvas');
       outCanvas.width = w; outCanvas.height = h;
 
       // OpenCV 사용 가능하면 고급 처리
       if (window.cv && cv && typeof cv.Mat !== 'undefined') {
         try {
           // srcCanvas를 읽어와서 처리
           const src = cv.imread(srcCanvas);
           let gray = new cv.Mat();
           cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
           // 엣지 보존 노이즈 제거: bilateral -> median
           let tmp = new cv.Mat();
           cv.bilateralFilter(gray, tmp, 9, 75, 75, cv.BORDER_DEFAULT);
           cv.medianBlur(tmp, tmp, 5);
           // 적응 임계: 블록사이즈 작게(세부 획 보존), C값 보정
           let dst = new cv.Mat();
           cv.adaptiveThreshold(tmp, dst, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 15, 5);
           // morphology: 먼저 closing으로 획 연결 -> open으로 잡점 제거 -> 약한 팽창으로 획 강화 -> 약한 침식으로 두께 안정화
           let M_close = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3,3));
           let M_open = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(2,2));
           cv.morphologyEx(dst, dst, cv.MORPH_CLOSE, M_close);
           cv.morphologyEx(dst, dst, cv.MORPH_OPEN, M_open);
           cv.dilate(dst, dst, M_open, new cv.Point(-1,-1), 1);
           cv.erode(dst, dst, M_open, new cv.Point(-1,-1), 1);
           tmp.delete(); M_close.delete(); M_open.delete();
 
           // 자동 반전: 전체 평균 밝기 보고 텍스트/배경 반전 여부 판단
           let mean = cv.mean(dst)[0];
           // mean이 높으면(대체로 배경 흰색) 그대로, 낮으면 반전 필요할 수 있음
           if (mean < 127) {
             // 배경 어두움 -> 반전하여 흰 배경/검정 글자가 되게 함 (Tesseract에 유리)
             cv.bitwise_not(dst, dst);
           }
 
           // 결과를 outCanvas에 그리기
           cv.imshow(outCanvas, dst);
           // 메모리 해제
           src.delete(); gray.delete(); dst.delete();
 
           if (debugPreview) document.body.appendChild(outCanvas);
           return outCanvas;
         } catch (e) {
           console.warn('OpenCV 처리 실패, fallback 사용:', e);
           // fallback으로 내려감
         }
       }
 
       // fallback: 기존 알고리즘 + 간단한 팽창(획 강화) + 소형 잡점 제거
       const ctx = outCanvas.getContext('2d');
       ctx.imageSmoothingEnabled = false;
       ctx.drawImage(srcCanvas, 0, 0, w, h);
       let img = ctx.getImageData(0, 0, w, h);
       let data = img.data;
       // 그레이스케일
       for (let i = 0; i < data.length; i += 4) {
         const r = data[i], g = data[i+1], b = data[i+2];
         const lum = Math.round(0.299*r + 0.587*g + 0.114*b);
         data[i] = data[i+1] = data[i+2] = lum;
       }
       // Otsu 대체: 간단 적응 임계(블럭 기반)
       const block = 32;
       for (let by = 0; by < h; by += block) {
         for (let bx = 0; bx < w; bx += block) {
           let sum = 0, cnt = 0;
           for (let y = by; y < Math.min(h, by+block); y++) {
             for (let x = bx; x < Math.min(w, bx+block); x++) {
               const idx = (y*w + x) * 4;
               sum += data[idx];
               cnt++;
             }
           }
           const thr = Math.max(0, Math.min(255, Math.round(sum / cnt)));
           for (let y = by; y < Math.min(h, by+block); y++) {
             for (let x = bx; x < Math.min(w, bx+block); x++) {
               const idx = (y*w + x) * 4;
               const v = data[idx] >= thr ? 255 : 0;
               data[idx] = data[idx+1] = data[idx+2] = v;
             }
           }
         }
       }
       // 간단한 소거: 1px 팽창(획 강화)
       const copy = new Uint8ClampedArray(data);
       const kernel = [-1,0,1,-w,0,w,w-1,w,w+1];
       for (let y = 1; y < h-1; y++) {
         for (let x = 1; x < w-1; x++) {
           const idx = (y*w + x) * 4;
           if (data[idx] === 0) { // 검정이면 주변 흰색과 연결되지 않도록
             let anyBlack = false;
             for (let ky = -1; ky <= 1 && !anyBlack; ky++) {
               for (let kx = -1; kx <= 1; kx++) {
                 const ni = ((y+ky)*w + (x+kx)) * 4;
                 if (data[ni] === 0) { anyBlack = true; break; }
               }
             }
             if (!anyBlack) {
               // 잡점으로 판단 -> 흰색으로 제거
               copy[idx] = copy[idx+1] = copy[idx+2] = 255;
             }
           }
         }
       }
       img.data.set(copy);
       ctx.putImageData(img, 0, 0);
       if (debugPreview) document.body.appendChild(outCanvas);
       return outCanvas;
     }

     // 문자 단위 분할 후 개별 인식 (보완판: 수평 프로젝션 기반 분할 + 퍼스트폴백)
    async function segmentAndRecognize(procCanvas) {
      const WHITELIST = 'ㄱㄲㄴㄷㄸㄹㅁㅂㅃㅅㅆㅇㅈㅉㅊㅋㅌㅍㅎ';
      
      // 고정 간격 분할 (자음 퀴즈는 글자 크기 동일)
      const w = procCanvas.width, h = procCanvas.height;
      
      // 1) 자동 글자 수 추정: 너비를 높이 기준으로 나눔 (자음은 정사각형에 가까움)
      const avgCharWidth = Math.max(h * 0.7, 20); // 최소 20px
      let numChars = Math.max(1, Math.round(w / avgCharWidth));
      numChars = Math.min(12, numChars); // 최대 12자
      
      log(`고정분할: 추정 글자수=${numChars}, 전체너비=${w}, 글자당너비=${Math.floor(w/numChars)}`);
      
      const charWidth = Math.floor(w / numChars);
      const results = [];
      
      for (let i = 0; i < numChars; i++) {
        const sx = i * charWidth;
        const sw = (i === numChars - 1) ? (w - sx) : charWidth; // 마지막은 남은 전체
        
        if (sw < 8) { results.push(''); continue; }
        
        // 여백 제거 (좌우 10%, 상하 5%)
        const marginX = Math.floor(sw * 0.1);
        const marginY = Math.floor(h * 0.05);
        const sx2 = sx + marginX, sy2 = marginY;
        const sw2 = Math.max(1, sw - marginX * 2);
        const sh2 = Math.max(1, h - marginY * 2);
        
        const charCanvas = document.createElement('canvas');
        charCanvas.width = sw2; charCanvas.height = sh2;
        const ctx = charCanvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(procCanvas, sx2, sy2, sw2, sh2, 0, 0, sw2, sh2);
        
        // 개별 인식 시도
        let charText = '';
        try {
          if (ocrWorker && typeof ocrWorker.setParameters === 'function' && !ocrWorker._fallback) {
            await ocrWorker.setParameters({ 
              tessedit_pageseg_mode: '10',
              tessedit_char_whitelist: WHITELIST,
              tessedit_ocr_engine_mode: '1' // LSTM only
            });
            const rres = await ocrWorker.recognize(charCanvas);
            charText = (rres?.data?.text || rres?.text || '').trim();
          } else {
            const rres = await Tesseract.recognize(charCanvas, 'kor', {
              langPath: TESSDATA_BASE,
              tessedit_pageseg_mode: '10',
              tessedit_char_whitelist: WHITELIST,
              tessedit_ocr_engine_mode: '1'
            });
            charText = (rres?.data?.text || rres?.text || '').trim();
          }
        } catch (e) {
          log(`문자 ${i+1} 인식 실패: ${e?.message}`);
          charText = '';
        }
        
        // 후보정: 빈 문자 또는 공백만 있으면 픽셀 밀도 기반 추정
        if (!charText || /^\s*$/.test(charText)) {
          charText = guessCharByDensity(charCanvas);
          log(`문자 ${i+1}: Tesseract 실패 -> 밀도추정="${charText}"`);
        } else {
          charText = charText.replace(/[^\u3131-\u314E]/g, ''); // 자음만
          log(`문자 ${i+1}: Tesseract="${charText}"`);
        }
        
        results.push(charText || '');
      }
      
      // PSM 복원
      try { 
        if (ocrWorker?.setParameters && !ocrWorker._fallback) 
          await ocrWorker.setParameters({ tessedit_pageseg_mode: '7' }); 
      } catch(_) {}
      
      return results.join('');
    }

    // 픽셀 밀도 기반 간단 추정 (fallback용)
    function guessCharByDensity(canvas) {
      const w = canvas.width, h = canvas.height;
      const ctx = canvas.getContext('2d');
      const img = ctx.getImageData(0, 0, w, h).data;
      
      // 9분할 영역별 밀도 계산
      const regions = {
        topLeft: 0, topCenter: 0, topRight: 0,
        midLeft: 0, midCenter: 0, midRight: 0,
        botLeft: 0, botCenter: 0, botRight: 0
      };
      
      const w3 = Math.floor(w / 3), h3 = Math.floor(h / 3);
      
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const v = img[(y * w + x) * 4];
          if (v < 128) { // 검정 픽셀
            const rx = Math.floor(x / w3), ry = Math.floor(y / h3);
            const key = ['top','mid','bot'][Math.min(2,ry)] + ['Left','Center','Right'][Math.min(2,rx)];
            regions[key]++;
          }
        }
      }
      
      // 간단한 규칙 기반 추정 (확장 가능)
      const total = Object.values(regions).reduce((a,b)=>a+b, 0);
      if (total < 5) return ''; // 거의 빈칸
      
      // ㅋ: 중앙우 + 우상/우중 밀도 높음
      if (regions.midRight > regions.midLeft * 1.5 && regions.topRight > 3) return 'ㅋ';
      // ㅌ: 상단 전체 + 중앙
      if (regions.topCenter > regions.botCenter * 1.3) return 'ㅌ';
      // ㅇ: 중앙 밀도 낮고 외곽 밀도 높음
      if (regions.midCenter < total * 0.15 && total > 10) return 'ㅇ';
      // ㄹ: 좌측 상단+중단
      if (regions.topLeft > regions.topRight && regions.midLeft > regions.midRight) return 'ㄹ';
      // ㅅ: 상단 중앙
      if (regions.topCenter > Math.max(regions.midCenter, regions.botCenter) * 1.2) return 'ㅅ';
      // ㅂ: 하단 밀도
      if (regions.botCenter > regions.topCenter * 1.1) return 'ㅂ';
      
      return ''; // 알 수 없음
    }

     async function doCaptureAndLookup() {
       try {
        // 비디오/캔버스 준비 상태 확인
        if (!video || !canvas) {
          throw new Error('video 또는 canvas 요소 없음');
        }
        if (!video.videoWidth || !video.videoHeight || video.readyState < 2) {
          log('비디오가 준비되지 않음 - 스킵');
          return;
        }
        const rect = video.getBoundingClientRect();
        const ctx = canvas.getContext && canvas.getContext('2d');
        if (!ctx) throw new Error('캔버스 2D 컨텍스트 생성 실패');
 
         if (selection) {
           // 선택 좌표를 비디오 원해상도에 매핑
           const scaleX = video.videoWidth / rect.width;
           const scaleY = video.videoHeight / rect.height;
           const sx = Math.round(selection.x * scaleX);
           const sy = Math.round(selection.y * scaleY);
           const sw = Math.round(selection.w * scaleX);
           const sh = Math.round(selection.h * scaleY);
           if (sw <= 0 || sh <= 0) {
             log('선택영역 크기 0 - 스킵');
             return;
           }
           canvas.width = sw; canvas.height = sh;
           try { ctx.drawImage(video, sx, sy, sw, sh, 0, 0, sw, sh); }
           catch(drawErr) { throw new Error('drawImage 실패: ' + (drawErr && drawErr.message || drawErr)); }
           log(`캡쳐: 선택영역 (${sx},${sy},${sw}x${sh})`);
         } else {
           const cw = video.videoWidth, ch = video.videoHeight;
           if (cw <= 0 || ch <= 0) { log('비디오 해상도 0 - 스킵'); return; }
           canvas.width = cw; canvas.height = ch;
           try { ctx.drawImage(video, 0, 0, canvas.width, canvas.height); }
           catch(drawErr) { throw new Error('drawImage 실패: ' + (drawErr && drawErr.message || drawErr)); }
           log(`캡쳐: 전체 프레임 (${canvas.width}x${canvas.height})`);
         }
 
         if (!ocrWorker) {
           log('OCR 워커 미초기화, 초기화 시도...');
           await startOCR();
           if (!ocrWorker) {
             setStatus('OCR 워커 생성 실패');
             return;
           }
         }
 
         setStatus('OCR 인식 시작...');
         setProgress(0);
         // 전처리 (스케일은 preprocessCanvas 기본값 사용 - 현재 6)
         const procCanvas = preprocessCanvas(canvas); // 스케일은 함수 기본값(권장: 6)
         // 문자 분할 후 개별 인식 시도 (한글 자음 전용으로 안정화됨)
         let rawText = '';
         try {
           rawText = await segmentAndRecognize(procCanvas);
         } catch (e) {
           log('문자 분할 인식 실패, 전체 인식으로 대체: ' + (e && (e.message || e)));
           // 마지막 수단: 전체 인식
           try {
             const allRes = ocrWorker && !ocrWorker._fallback ? await ocrWorker.recognize(procCanvas) : await Tesseract.recognize(procCanvas, 'kor', { langPath: TESSDATA_BASE });
             rawText = (allRes && allRes.data && allRes.data.text) ? allRes.data.text : (allRes && allRes.text ? allRes.text : '');
           } catch (e2) {
             log('전체 인식도 실패: ' + (e2 && (e2.message || e2)));
             rawText = '';
           }
         }
         // OCR 완료
         setStatus('OCR 완료');
         // OCR 원문 가져오기 (createWorker와 fallback 결과 인터페이스 차이 고려)
         const finalText = rawText.replace(/[^\u1100-\u11FF\u3130-\u318F\uAC00-\uD7A3\s]/g, '');
         liveTextEl.textContent = finalText.trim() || '(인식된 텍스트 없음)';
         log('OCR 원문(요약): ' + (finalText ? finalText.replace(/\s+/g,' ').slice(0,200) + (finalText.length>200? '…':'') : '(빈문자열)'));
         
         // 한글에서 자음만 추출하여 줄 단위로 분리
         const consonantExtracted = finalText.replace(/[^\u1100-\u11FF\u3130-\u318F\uAC00-\uD7A3\s]/g, '');
         const lines = consonantExtracted.split(/\r?\n/).map(s => s.trim()).filter(s => s);
         log('추출된 라인(한글만 필터): ' + JSON.stringify(lines.slice(0,5)));
         
         // 한 줄만 사용: 첫 줄(문제 텍스트)
         const raw1 = lines[0] || '';
         // normalizeKey에서 자음만 추출하므로 "안녕하세요" -> "ㅇㄴㄴㅇㅎㅅㅇ"로 변환됨
         const key1 = normalizeKey(raw1);
         log(`정규화 키(자음 추출): [${raw1} -> ${key1}]`);
 
         // 1열 기준으로 모든 2열값을 조회 (자음 기준 매칭)
         const matches = dbIndex.get(key1) || [];
         if (matches.length > 0) {
           setStatus('DB 일치 항목 발견: ' + matches.length + '개');
           log('DB 매칭(자음 기준): ' + key1 + ' -> ' + JSON.stringify(matches));
           renderResults(matches);
         } else {
           setStatus('DB 매칭 없음');
           log('DB 매칭 없음 (자음키=' + key1 + ')');
           renderResults([]);
         }
       } catch (e) {
         const emsg = (e && (e.message || e.toString())) || 'unknown error';
         setStatus('doCapture 에러: ' + emsg);
         log('doCapture 예외: ' + emsg + '\n' + (e && e.stack ? e.stack : 'stack 없음'));
       }
     }
     // ========== TensorFlow.js 자음 분류기 ==========
let cnnModel = null;
const CONSONANTS = ['ㄱ','ㄲ','ㄴ','ㄷ','ㄸ','ㄹ','ㅁ','ㅂ','ㅃ','ㅅ','ㅆ','ㅇ','ㅈ','ㅉ','ㅊ','ㅋ','ㅌ','ㅍ','ㅎ']; // 19개 (ㄲ,ㄸ,ㅃ,ㅆ,ㅉ 포함)
const IMG_SIZE = 32; // 입력 이미지 크기 (32x32 grayscale)

// 모델 생성 (경량 CNN: Conv2D + MaxPool + Dense)
function createCNNModel() {
  const model = tf.sequential();
  
  // Input: 32x32x1 (grayscale)
  model.add(tf.layers.conv2d({
    inputShape: [IMG_SIZE, IMG_SIZE, 1],
    filters: 16,
    kernelSize: 3,
    activation: 'relu',
    padding: 'same'
  }));
  model.add(tf.layers.maxPooling2d({ poolSize: 2 })); // 16x16
  
  model.add(tf.layers.conv2d({
    filters: 32,
    kernelSize: 3,
    activation: 'relu',
    padding: 'same'
  }));
  model.add(tf.layers.maxPooling2d({ poolSize: 2 })); // 8x8
  
  model.add(tf.layers.flatten());
  model.add(tf.layers.dense({ units: 64, activation: 'relu' }));
  model.add(tf.layers.dropout({ rate: 0.3 }));
  model.add(tf.layers.dense({ units: CONSONANTS.length, activation: 'softmax' }));
  
  model.compile({
    optimizer: tf.train.adam(0.001),
    loss: 'categoricalCrossentropy',
    metrics: ['accuracy']
  });
  
  log('CNN 모델 생성 완료: ' + model.summary());
  return model;
}

// Canvas를 32x32 grayscale tensor로 변환
function canvasToTensor(canvas) {
  // 1) 32x32로 리사이즈
  const resized = document.createElement('canvas');
  resized.width = IMG_SIZE;
  resized.height = IMG_SIZE;
  const ctx = resized.getContext('2d');
  ctx.imageSmoothingEnabled = true;
  ctx.drawImage(canvas, 0, 0, IMG_SIZE, IMG_SIZE);
  
  // 2) grayscale + normalize [0,1]
  const imgData = ctx.getImageData(0, 0, IMG_SIZE, IMG_SIZE);
  const data = imgData.data;
  const gray = new Float32Array(IMG_SIZE * IMG_SIZE);
  
  for (let i = 0, j = 0; i < data.length; i += 4, j++) {
    const r = data[i], g = data[i+1], b = data[i+2];
    gray[j] = (0.299*r + 0.587*g + 0.114*b) / 255.0; // normalize to [0,1]
  }
  
  // 3) tensor shape: [1, 32, 32, 1]
  return tf.tensor4d(gray, [1, IMG_SIZE, IMG_SIZE, 1]);
}

// 모델 로드 시도 (로컬 storage 또는 URL)
async function loadCNNModel() {
  try {
    // 1) IndexedDB에서 로드 시도
    cnnModel = await tf.loadLayersModel('indexeddb://korean-consonant-cnn');
    log('CNN 모델 로드 완료 (IndexedDB)');
    return true;
  } catch (e) {
    log('CNN 모델 미존재 또는 로드 실패: ' + e.message);
    // 2) 새로 생성 (학습 필요)
    cnnModel = createCNNModel();
    log('CNN 모델 새로 생성 - 학습 데이터 필요');
    return false;
  }
}

// 예측 (단일 문자 캔버스 -> 자음)
async function predictChar(charCanvas) {
  if (!cnnModel) {
    log('CNN 모델 미로드 - Tesseract fallback');
    return null;
  }
  
  const tensor = canvasToTensor(charCanvas);
  const pred = cnnModel.predict(tensor);
  const probs = await pred.data();
  tensor.dispose();
  pred.dispose();
  
  // 최대 확률 인덱스
  let maxIdx = 0, maxProb = probs[0];
  for (let i = 1; i < probs.length; i++) {
    if (probs[i] > maxProb) {
      maxProb = probs[i];
      maxIdx = i;
    }
  }
  
  // 신뢰도 낮으면 null 반환 (Tesseract fallback)
  if (maxProb < 0.5) {
    log(`CNN 신뢰도 낮음(${(maxProb*100).toFixed(1)}%) - fallback`);
    return null;
  }
  
  const result = CONSONANTS[maxIdx];
  log(`CNN 예측: ${result} (신뢰도 ${(maxProb*100).toFixed(1)}%)`);
  return result;
}

// ========== segmentAndRecognize 함수 수정 (CNN 우선 사용) ==========
async function segmentAndRecognize(procCanvas) {
  const WHITELIST = 'ㄱㄲㄴㄷㄸㄹㅁㅂㅃㅅㅆㅇㅈㅉㅊㅋㅌㅍㅎ';
  
  const w = procCanvas.width, h = procCanvas.height;
  const avgCharWidth = Math.max(h * 0.7, 20);
  let numChars = Math.max(1, Math.round(w / avgCharWidth));
  numChars = Math.min(12, numChars);
  
  log(`고정분할: 추정 글자수=${numChars}, 전체너비=${w}`);
  
  const charWidth = Math.floor(w / numChars);
  const results = [];
  
  for (let i = 0; i < numChars; i++) {
    const sx = i * charWidth;
    const sw = (i === numChars - 1) ? (w - sx) : charWidth;
    
    if (sw < 8) { results.push(''); continue; }
    
    const marginX = Math.floor(sw * 0.1);
    const marginY = Math.floor(h * 0.05);
    const sx2 = sx + marginX, sy2 = marginY;
    const sw2 = Math.max(1, sw - marginX * 2);
    const sh2 = Math.max(1, h - marginY * 2);
    
    const charCanvas = document.createElement('canvas');
    charCanvas.width = sw2; charCanvas.height = sh2;
    const ctx = charCanvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(procCanvas, sx2, sy2, sw2, sh2, 0, 0, sw2, sh2);
    
    let charText = '';
    
    // 1) CNN 모델 우선 시도
    if (cnnModel) {
      charText = await predictChar(charCanvas);
    }
    
    // 2) CNN 실패 시 Tesseract fallback
    if (!charText) {
      try {
        if (ocrWorker && typeof ocrWorker.setParameters === 'function' && !ocrWorker._fallback) {
          await ocrWorker.setParameters({ 
            tessedit_pageseg_mode: '10',
            tessedit_char_whitelist: WHITELIST,
            tessedit_ocr_engine_mode: '1'
          });
          const rres = await ocrWorker.recognize(charCanvas);
          charText = (rres?.data?.text || rres?.text || '').trim();
        } else {
          const rres = await Tesseract.recognize(charCanvas, 'kor', {
            langPath: TESSDATA_BASE,
            tessedit_pageseg_mode: '10',
            tessedit_char_whitelist: WHITELIST
          });
          charText = (rres?.data?.text || rres?.text || '').trim();
        }
        charText = charText.replace(/[^\u3131-\u314E]/g, '');
        log(`문자 ${i+1}: Tesseract="${charText}"`);
      } catch (e) {
        log(`문자 ${i+1}: Tesseract 실패 - ${e?.message}`);
        charText = '';
      }
    }
    
    // 3) 여전히 빈칸이면 밀도 추정
    if (!charText) {
      charText = guessCharByDensity(charCanvas);
      log(`문자 ${i+1}: 밀도추정="${charText}"`);
    }
    
    results.push(charText || '');
  }
  
  try { 
    if (ocrWorker?.setParameters && !ocrWorker._fallback) 
      await ocrWorker.setParameters({ tessedit_pageseg_mode: '7' }); 
  } catch(_) {}
  
  return results.join('');
}

// ========== startBtn 이벤트 핸들러 수정 (CNN 로드 추가) ==========
startBtn.addEventListener('click', async () => {
  try {
    await loadCSV();
    await loadCNNModel(); // CNN 모델 로드 (없으면 생성)
    await startOCR();
    
    setStatus('화면 공유 권한 요청...');
    stream = await navigator.mediaDevices.getDisplayMedia({ video: true });
    video.srcObject = stream;
    previewWrap.style.display = 'inline-block';

    video.addEventListener('loadedmetadata', () => {
      setTimeout(() => {
        fitOverlayToVideo();
        log('비디오 메타데이터 로드: ' + video.videoWidth + 'x' + video.videoHeight);
      }, 50);
    });
    window.addEventListener('resize', fitOverlayToVideo);

    startBtn.disabled = true;
    stopBtn.disabled = false;
    status.textContent = '화면 공유 중... OCR 실행 중';
    resetSelBtn.disabled = true;

    // 빠른 디버깅을 위해 1초 간격으로 캡쳐+OCR, 필요시 늘릴 것
    ocrInterval = setInterval(() => {
      doCaptureAndLookup().catch(e => console.error(e));
    }, 1000);

    log('주기적 OCR 시작 (1초)');
  } catch (e) {
    setStatus('시작 실패: ' + e.message);
    log('startBtn 에러: ' + e.stack);
  }
 });

     stopBtn.addEventListener('click', () => {
       if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
       if (ocrInterval) { clearInterval(ocrInterval); ocrInterval = null; }
       startBtn.disabled = false;
       stopBtn.disabled = true;
       setStatus('중지됨');
       previewWrap.style.display = 'none';
       selection = null;
       drawSelection();
       log('화면 공유 중지 및 리소스 해제');
     });

     // 결과 렌더링: 배열을 받아 각 항목별 복사 버튼 생성
     function renderResults(list) {
       resultDiv.innerHTML = ''; // 초기화
       if (!list || list.length === 0) {
         resultDiv.textContent = '데이터베이스에서 일치 항목 없음';
         copyBtn.disabled = true;
         return;
       }
       const ul = document.createElement('div');
       ul.style.display = 'flex';
       ul.style.flexDirection = 'column';
       ul.style.gap = '6px';
       list.forEach((val, idx) => {
         const row = document.createElement('div');
         row.style.display = 'flex';
         row.style.alignItems = 'center';
         row.style.gap = '8px';

         const txt = document.createElement('span');
         txt.textContent = val;
         txt.style.padding = '6px 8px';
         txt.style.border = '1px solid #ddd';
         txt.style.borderRadius = '4px';
         txt.style.background = '#f9f9f9';

         const btn = document.createElement('button');
         btn.textContent = '복사';
         btn.addEventListener('click', async () => {
           try {
             await navigator.clipboard.writeText(val);
             setStatus(`클립보드에 복사됨: "${val}"`);
             log(`항목 복사: ${val}`);
           } catch (e) {
             setStatus('복사 실패: ' + e.message);
             log('copy error: ' + e.stack);
           }
         });

         row.appendChild(txt);
         row.appendChild(btn);
         ul.appendChild(row);
       });
       resultDiv.appendChild(ul);
       copyBtn.disabled = true; // 개별 버튼으로 복사하도록 전역 복사 버튼 비활성
     }

     window.addEventListener('beforeunload', async () => {
       try {
         if (stream) stream.getTracks().forEach(t => t.stop());
         if (ocrWorker) {
           if (typeof ocrWorker.terminate === 'function') {
             // createWorker의 terminate가 프로미스일 경우 await
             const term = ocrWorker.terminate();
             if (term && typeof term.then === 'function') await term;
           }
         }
       } catch (e) {
         log('종료 중 에러: ' + e.message);
       }
     });
  // 실시간 텍스트 복사 버튼 동작
  if (copyLiveBtn) {
    copyLiveBtn.addEventListener('click', async () => {
      try {
        const txt = (liveTextEl && liveTextEl.textContent) ? liveTextEl.textContent.trim() : '';
        if (!txt) { setStatus('복사할 실시간 텍스트 없음'); return; }
        await navigator.clipboard.writeText(txt);
        setStatus('실시간 텍스트 클립보드에 복사됨');
        log('실시간 텍스트 복사');
      } catch (e) {
        setStatus('실시간 복사 실패: ' + (e && e.message));
        log('copyLiveBtn error: ' + (e && e.stack));
      }
    });
  }
   </script>
 </body>
</html>